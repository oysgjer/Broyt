<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>KartTegner ‚Äì br√∏ytekart (feltmodus + natt + kompass)</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);

      /* theme vars (overridden in [data-theme="dark"]) */
      --bg-header: #0f172a;
      --bg-btn: #1e293b;
      --bd-btn: #334155;
      --fg: #ffffff;
      --legend-bg: #ffffff;
      --legend-bd: #e5e7eb;
      --status-bg: #f8fafc;
      --status-bd: #e5e7eb;
      --pill-bg: #eef2ff;
      --pill-fg: #3730a3;
      --pill-bd: #c7d2fe;
    }
    [data-theme="dark"] {
      --bg-header: #0b1220;
      --bg-btn: #111827;
      --bd-btn: #374151;
      --fg: #e5e7eb;
      --legend-bg: #0f172a;
      --legend-bd: #1f2937;
      --status-bg: #0b1220;
      --status-bd: #1f2937;
      --pill-bg: #1f2937;
      --pill-fg: #cbd5e1;
      --pill-bd: #334155;
    }

    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--status-bg); color: var(--fg); }
    #app { display: grid; grid-template-rows: auto 1fr auto; height: 100dvh; overflow:hidden; }

    header {
      padding: calc(8px + var(--safe-top)) 12px 8px 12px;
      background: var(--bg-header); color: var(--fg); display: flex; align-items: center;
      justify-content: space-between; position: sticky; top: 0; z-index: 1000;
    }
    .brand { display:flex; align-items:center; gap:.6rem; }
    .brand h1 { font-size: 1rem; margin: 0; font-weight: 600; }
    .quick { display:flex; align-items:center; gap:.5rem; }

    .hamburger {
      width: 40px; height: 40px; border-radius:10px; border:1px solid var(--bd-btn);
      background:var(--bg-btn); display:grid; place-items:center; cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .hamburger div { width:18px; height:2px; background:var(--fg); position:relative; }
    .hamburger div::before, .hamburger div::after {
      content:""; position:absolute; left:0; width:18px; height:2px; background:var(--fg);
    }
    .hamburger div::before{ top:-6px; } .hamburger div::after{ top:6px; }

    .drawer {
      position: fixed; top:0; right:0; height:100%; width:min(92vw,420px);
      background:var(--bg-header); color:var(--fg); transform: translateX(100%);
      transition: transform .25s ease; z-index: 1200; display:flex; flex-direction:column;
      padding: calc(10px + var(--safe-top)) 12px 12px 12px; border-left:1px solid var(--bd-btn);
    }
    .drawer.open { transform: translateX(0); }
    .drawer h2{ margin:0 0 .6rem 0; font-size:1rem }
    .group{ margin: .6rem 0 1rem 0; }
    .group h3{ font-size:.9rem; color:#9aa4bd; margin:.2rem 0 .4rem 0 }
    .btn {
      background: var(--bg-btn); color: var(--fg); border: 1px solid var(--bd-btn);
      padding: .7rem .9rem; border-radius: .7rem; cursor: pointer;
      touch-action: manipulation; -webkit-tap-highlight-color: transparent;
      font-size: 1rem; display:block; width:100%; text-align:left; margin:.4rem 0;
    }
    .btn.inline { width:auto; display:inline-block; text-align:center; }
    .row { display:flex; gap:.5rem; flex-wrap:wrap; }
    .note { color:#9aa4bd; font-size:.85rem; }

    #mapWrap { position:relative; overflow:hidden; background:#000; }
    #map { height: 100%; width: 100%; transform-origin:center center; }

    #statusbar {
      padding: 8px 12px calc(8px + var(--safe-bottom));
      background: var(--status-bg); border-top: 1px solid var(--status-bd);
      display: grid; grid-template-columns: 1fr; gap: .5rem; align-items: center;
      color: var(--fg);
    }
    @media (min-width: 720px) {
      #statusbar { grid-template-columns: 1fr auto; }
    }
    .progress { height: 12px; background: #475569; border-radius: 999px; overflow: hidden; }
    .progress > div { height: 100%; width: 0%; background: #16a34a; transition: width .3s ease; }
    .pill { font-size: .9rem; background: var(--pill-bg); color: var(--pill-fg); border: 1px solid var(--pill-bd); padding: .25rem .5rem; border-radius: 999px; }

    .legend {
      position: fixed; right: calc(12px + var(--safe-right)); top: calc(64px + var(--safe-top));
      background: var(--legend-bg); border: 1px solid var(--legend-bd); padding: .6rem; border-radius: .6rem;
      box-shadow: 0 4px 18px rgba(0,0,0,.18); z-index: 900; color:#111;
    }
    [data-theme="dark"] .legend{ color:#e5e7eb; }
    .legend h3{ margin:0 0 .5rem 0; font-size:.95rem }
    .legend .row{ font-size:.85rem; margin:.15rem 0; display:flex; align-items:center; gap:.35rem }
    .swatch{ width: 10px; height: 10px; border-radius: 2px; display:inline-block }
    .swatch.route{ background:#ef4444 }
    .swatch.covered{ background:#16a34a }
    .swatch.gps{ background:#3b82f6 }

    #btnTilbake {
      position: fixed;
      bottom: env(safe-area-inset-bottom, 0px);
      left: 0;
      width: 100%;
      background: var(--bg-header);
      color: var(--fg);
      font-size: 18px;
      padding: 14px 0;
      border: none;
      border-top: 1px solid var(--bd-btn);
      cursor: pointer;
      z-index: 1100;
    }

    .heading-arrow {
      width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent;
      border-bottom: 10px solid #1e40af;
      position: relative; top: -6px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,.6));
    }

    /* Compass control */
    .compass {
      position: fixed;
      left: calc(12px + var(--safe-left));
      top: calc(64px + var(--safe-top));
      z-index: 950;
      width: 44px; height: 44px;
      border-radius: 10px;
      background: var(--legend-bg);
      border:1px solid var(--legend-bd);
      display:grid; place-items:center;
      box-shadow: 0 2px 12px rgba(0,0,0,.12);
    }
    .compass .rose {
      width: 20px; height: 20px;
      border: 2px solid #ef4444; border-radius: 999px;
      position: relative;
    }
    .compass .needle {
      position: absolute; left: 50%; top: 0;
      transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 6px solid transparent; border-right: 6px solid transparent;
      border-bottom: 12px solid #ef4444;
    }
    .compass .label {
      position: absolute; bottom: -18px; left: 50%; transform: translateX(-50%);
      font-size: 10px; color: #666;
    }
    [data-theme="dark"] .compass .label { color:#cbd5e1; }
  </style>
</head>
<body>
<div id="app" data-theme="light">
  <header>
    <div class="brand">
      <div class="hamburger" id="btnMenu"><div></div></div>
      <h1>KartTegner</h1>
    </div>
    <div class="quick">
      <button id="btnFollow" class="btn inline">üìç Sentrer (av)</button>
    </div>
  </header>

  <div id="mapWrap">
    <div id="map"></div>
  </div>

  <div id="statusbar">
    <div class="progress" aria-label="Dekningsgrad"><div id="bar"></div></div>
    <div style="display:flex; gap:.5rem; align-items:center; flex-wrap: wrap;">
      <span id="coverage" class="pill">Dekning: 0%</span>
      <span id="distance" class="pill">Rutelengde: 0 m</span>
      <span id="fix" class="pill">GPS: ‚Äì</span>
    </div>
  </div>
</div>

<!-- Drawer menu -->
<aside class="drawer" id="drawer">
  <h2>Meny</h2>
  <div class="group">
    <h3>Navigasjon</h3>
    <div class="row">
      <button class="btn" id="btnStartGPS">‚ñ∂Ô∏è Start GPS</button>
      <button class="btn" id="btnStopGPS">‚èπÔ∏è Stopp</button>
      <button class="btn" id="btnCourseUp">üß≠ Kj√∏reretning opp (beta)</button>
      <button class="btn" id="btnWake">üì± Hold skjerm p√• (av)</button>
      <button class="btn" id="btnTheme">üåô Nattmodus: Auto</button>
    </div>
    <div class="note">‚ÄúKj√∏reretning opp (beta)‚Äù roterer kartet visuelt etter heading. Nattmodus styrer bakgrunnskart + farger.</div>
  </div>

  <div class="group">
    <h3>Ruter</h3>
    <button class="btn" id="btnDraw">‚úèÔ∏è Tegn linje</button>
    <button class="btn" id="btnFinish">‚úÖ Avslutt tegning</button>
    <button class="btn" id="btnLoadBin">üì• Last fra JSONBin</button>
    <button class="btn" id="btnSaveBin">üíæ Lagre til JSONBin</button>
  </div>

  <div class="group">
    <h3>Test & filer</h3>
    <button class="btn" id="btnSimulate">üß™ Simul√©r</button>
    <button class="btn" id="btnExport">‚¨áÔ∏è Eksporter GeoJSON</button>
    <button class="btn" id="btnImport">‚¨ÜÔ∏è Importer GeoJSON</button>
    <button class="btn" id="btnRestoreDraft" title="Gjenopprett siste lokale utkast">üìù Gjenopprett utkast</button>
  </div>

  <div class="group">
    <h3>Om</h3>
    <div class="note" id="metaInfo">v3 ‚Ä¢ natt + kompass</div>
  </div>
</aside>

<!-- Legend + Compass -->
<div class="legend">
  <h3>Tegnforklaring</h3>
  <div class="row"><span class="swatch route"></span> Rute(r)</div>
  <div class="row"><span class="swatch covered"></span> Dekket del</div>
  <div class="row"><span class="swatch gps"></span> GPS-spor</div>
</div>
<div class="compass" id="compass" title="Nord">
  <div class="rose">
    <div class="needle" id="compassNeedle"></div>
    <div class="label" id="compassLabel">N</div>
  </div>
</div>

<button id="btnTilbake">‚¨ÖÔ∏è Tilbake til arbeid</button>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script>
(function(){
  // ---------- Params & constants ----------
  const params = new URLSearchParams(location.hash.replace(/^#/, ''));
  const ADDR_BIN = params.get('addrBin') || params.get('bin') || '';
  const ADDR_KEY = params.get('addrKey') || params.get('key') || '';
  const ROUTE_BIN = params.get('routeBin') || ADDR_BIN;
  const ROUTE_KEY = params.get('routeKey') || ADDR_KEY;
  const FIELD = params.get('field') || 'geojsonRoutes';
  const BACK_URL = params.get('backUrl') || 'https://broyt.pages.dev/#work';
  const JSONBIN_API = 'https://api.jsonbin.io/v3/b';
  const LS_DRAFT = 'KARTTEGNER_DRAFT';
  const LS_THEME = 'KART_THEME_MODE'; // 'auto' | 'dark' | 'light'
  let remoteVersion = 0;

  // ---------- Theme & basemaps ----------
  // Light and dark tile layers
  const lightTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 20, attribution: '&copy; OpenStreetMap contributors'
  });
  const darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
    maxZoom: 20,
    attribution: '&copy; OpenStreetMap, ¬©Carto'
  });

  const appEl = document.getElementById('app');
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
  let themeMode = localStorage.getItem(LS_THEME) || 'auto';

  function effectiveDark(){
    if (themeMode === 'dark') return true;
    if (themeMode === 'light') return false;
    return !!(prefersDark && prefersDark.matches);
  }

  const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([60.2563, 11.1941], 14);
  function applyThemeToMap(){
    const dark = effectiveDark();
    appEl.setAttribute('data-theme', dark ? 'dark' : 'light');
    // swap tile layers
    if (dark){
      if (map.hasLayer(lightTiles)) map.removeLayer(lightTiles);
      if (!map.hasLayer(darkTiles)) darkTiles.addTo(map);
    } else {
      if (map.hasLayer(darkTiles)) map.removeLayer(darkTiles);
      if (!map.hasLayer(lightTiles)) lightTiles.addTo(map);
    }
    // button label
    const btn = document.getElementById('btnTheme');
    btn.textContent = 'üåô Nattmodus: ' + (themeMode==='auto' ? 'Auto' : (themeMode==='dark' ? 'P√•' : 'Av'));
  }
  applyThemeToMap();
  if (prefersDark && prefersDark.addEventListener){
    prefersDark.addEventListener('change', applyThemeToMap);
  }
  document.getElementById('btnTheme').onclick = () => {
    themeMode = themeMode==='auto' ? 'dark' : (themeMode==='dark' ? 'light' : 'auto');
    localStorage.setItem(LS_THEME, themeMode);
    applyThemeToMap();
  };

  // ---------- Layers ----------
  const drawnLayer   = new L.FeatureGroup().addTo(map);
  const coveredLayer = new L.FeatureGroup().addTo(map);
  const gpsLayer     = new L.FeatureGroup().addTo(map);
  const addressLayer = new L.FeatureGroup().addTo(map);

  const drawControl = new L.Control.Draw({
    draw: { polygon:false, rectangle:false, circle:false, circlemarker:false, marker:false,
      polyline: { shapeOptions: { color:'#ef4444', weight:4 } } },
    edit: { featureGroup: drawnLayer }
  });

  // ---------- Drawer (hamburger) ----------
  const drawer = document.getElementById('drawer');
  document.getElementById('btnMenu').onclick = ()=> drawer.classList.toggle('open');

  // ---------- Follow me ----------
  let followEnabled = false;
  document.getElementById('btnFollow').addEventListener('click', () => {
    followEnabled = !followEnabled;
    const btn = document.getElementById('btnFollow');
    btn.textContent = followEnabled ? 'üìç Sentrer (p√•)' : 'üìç Sentrer (av)';
    btn.style.background = followEnabled ? '#15803d' : 'var(--bg-btn)';
    if(followEnabled && lastLatLng){
      const targetZoom = Math.max(map.getZoom() || 14, 16);
      map.setView(lastLatLng, targetZoom, { animate: true });
    }
  });
  map.on('dragstart', () => {
    if (followEnabled) {
      followEnabled = false;
      const btn = document.getElementById('btnFollow');
      btn.textContent = 'üìç Sentrer (av)';
      btn.style.background = 'var(--bg-btn)';
    }
  });

  // ---------- Drawing ----------
  let drawing = false;
  let dirty = false;
  document.getElementById('btnDraw').onclick = () => {
    drawing = true;
    new L.Draw.Polyline(map, drawControl.options.draw.polyline).enable();
  };
  document.getElementById('btnFinish').onclick = () => { map.fire('draw:drawstop'); drawing = false; };

  map.on(L.Draw.Event.CREATED, (e) => {
    const layer = e.layer;
    const name = prompt('Navn p√• strekning?', 'Ny br√∏ytestrek') || 'Uten navn';
    layer.feature = layer.feature || { type:'Feature', properties:{} };
    layer.feature.properties.name = name;
    layer.feature.properties.id = layer.feature.properties.id || (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random()));
    layer.addTo(drawnLayer);
    map.fitBounds(layer.getBounds(), { padding:[20,20] });
    recalcRouteStats();
    markDirty();
  });
  map.on(L.Draw.Event.EDITED, () => { recalcRouteStats(); markDirty(); });

  // ---------- Coverage sampling ----------
  let samples = [];
  const SAMPLE_EVERY_M = 5;
  const TOLERANCE_M = 12;
  let covered = new Set();

  function recalcRouteStats(){
    covered.clear();
    coveredLayer.clearLayers();
    const gjs = toGeoJSONMulti();
    if(!gjs || gjs.length===0) { updateUI(0, 0); samples=[]; return; }
    let meters = 0;
    samples = [];
    gjs.forEach(gj => {
      const lenKm = turf.length(gj, {units:'kilometers'});
      meters += Math.round(lenKm * 1000);
      const steps = Math.max(1, Math.ceil((lenKm*1000) / SAMPLE_EVERY_M));
      for(let i=0;i<=steps;i++){
        const distKm = (i * SAMPLE_EVERY_M) / 1000;
        const pt = turf.along(gj, distKm, {units:'kilometers'});
        samples.push(pt);
      }
    });
    updateUI(0, meters);
  }

  function toGeoJSONMulti(){
    const layers = drawnLayer.getLayers();
    if(layers.length===0) return [];
    return layers.map(l => l.toGeoJSON()).filter(f => f.geometry?.type==='LineString');
  }

  function updateUI(percent, meters){
    const bar = document.getElementById('bar');
    bar.style.width = `${percent}%`;
    document.getElementById('coverage').textContent = `Dekning: ${percent.toFixed(0)}%`;
    document.getElementById('distance').textContent = `Rutelengde: ${meters} m`;
  }
  function totalMeters(){
    const gjs = toGeoJSONMulti();
    let m=0; gjs.forEach(gj => m += Math.round(turf.length(gj,{units:'kilometers'})*1000));
    return m;
  }

  function markCovered(indices){
    if(!indices || indices.length===0) return;
    indices.forEach(i => covered.add(i));
    const coveredPts = Array.from(covered).sort((a,b)=>a-b).map(i=>samples[i]);
    if(coveredPts.length>0){
      coveredLayer.clearLayers();
      const coords = coveredPts.map(pt => pt.geometry.coordinates).map(c=>[c[1], c[0]]);
      L.polyline(coords, {color:'#16a34a', weight:6, opacity:0.6}).addTo(coveredLayer);
    }
    const pct = samples.length? Math.min(100, (covered.size / samples.length) * 100) : 0;
    const meters = totalMeters();
    updateUI(pct, meters);
  }

  // ---------- GPS + heading + course-up ----------
  let watchId = null;
  let gpsPolyline = null;
  const gpsCoords = [];
  let myDot = null;
  let headingMarker = null;
  let myAccuracy = null;
  let lastLatLng = null;
  let lastHeading = null;

  function ensureHeadingMarker(latlng){
    if (!headingMarker){
      const div = document.createElement('div');
      div.className = 'heading-arrow';
      const icon = L.divIcon({ className:'', html:div, iconSize:[12,10], iconAnchor:[6,6] });
      headingMarker = L.marker(latlng, { icon }).addTo(gpsLayer);
    }
  }

  function addGpsPoint(lat, lon, heading, accuracy){
    const latlng = [lat, lon];
    lastLatLng = latlng;
    lastHeading = (typeof heading === 'number' && !Number.isNaN(heading)) ? heading : lastHeading;

    gpsCoords.push(latlng);
    if(!gpsPolyline){
      gpsPolyline = L.polyline(gpsCoords, {color:'#3b82f6', weight:3}).addTo(gpsLayer);
    } else {
      gpsPolyline.setLatLngs(gpsCoords);
    }

    if(!myDot){
      myDot = L.circleMarker(latlng, { radius:5, color:'#1d4ed8', fillColor:'#1d4ed8', fillOpacity:1, stroke:false })
        .addTo(gpsLayer);
    } else {
      myDot.setLatLng(latlng);
    }

    ensureHeadingMarker(latlng);
    headingMarker.setLatLng(latlng);
    if (lastHeading != null){
      const el = headingMarker.getElement();
      if (el) el.style.transform = `rotate(${lastHeading}deg)`;
    }

    if (typeof accuracy === 'number'){
      if(!myAccuracy){
        myAccuracy = L.circle(latlng, { radius: Math.max(5, Math.min(100, accuracy)), color:'#3b82f6', weight:1, fillOpacity:0.1 })
          .addTo(gpsLayer);
      } else {
        myAccuracy.setLatLng(latlng);
        myAccuracy.setRadius(Math.max(5, Math.min(100, accuracy)));
      }
      document.getElementById('fix').textContent = `GPS: ${Math.round(accuracy)}m`;
    }

    if(samples.length>0){
      const pt = turf.point([lon, lat]);
      let nearestIdx = 0; let best = Infinity;
      for(let i=0;i<samples.length;i++){
        const d = turf.distance(pt, samples[i], {units:'kilometers'});
        if(d<best){ best=d; nearestIdx=i; }
      }
      const found = [];
      const maxJump = 25;
      for(let j=Math.max(0, nearestIdx-maxJump); j<=Math.min(samples.length-1, nearestIdx+maxJump); j++){
        const m = turf.distance(pt, samples[j], {units:'kilometers'}) * 1000;
        if(m <= TOLERANCE_M) found.push(j);
      }
      markCovered(found);
    }

    if(followEnabled){
      const targetZoom = Math.max(map.getZoom() || 14, 16);
      map.setView(latlng, targetZoom, { animate: true });
    }
  }

  function startGPS(){
    if(watchId!==null) return;
    if(!navigator.geolocation){ alert('Denne enheten st√∏tter ikke Geolocation. Bruk ¬´Simul√©r¬ª.'); return; }
    watchId = navigator.geolocation.watchPosition(pos => {
      const { latitude, longitude, accuracy, heading } = pos.coords;
      addGpsPoint(latitude, longitude, heading, accuracy);
    }, err => {
      document.getElementById('fix').textContent = 'GPS: feil';
      console.error(err);
      alert('Fikk ikke GPS. Du kan pr√∏ve ¬´Simul√©r¬ª p√• desktop.');
    }, { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 });
  }

  function stopGPS(){
    if(watchId!==null){ navigator.geolocation.clearWatch(watchId); watchId = null; }
    document.getElementById('fix').textContent = 'GPS: stoppet';
  }

  document.getElementById('btnStartGPS').onclick = startGPS;
  document.getElementById('btnStopGPS').onclick = stopGPS;

  // Course-up rotation
  let courseUp = false;
  const mapEl = document.getElementById('map');
  document.getElementById('btnCourseUp').onclick = () => {
    courseUp = !courseUp;
    document.getElementById('btnCourseUp').textContent = courseUp ? 'üß≠ Kj√∏reretning opp (p√•)' : 'üß≠ Kj√∏reretning opp (beta)';
    if(!courseUp){
      mapEl.style.transform = 'rotate(0deg)';
    } else if (lastHeading != null){
      mapEl.style.transform = `rotate(${-lastHeading}deg)`;
    }
    updateCompass();
  };
  function updateRotation(){
    if(courseUp && lastHeading != null){
      mapEl.style.transform = `rotate(${-lastHeading}deg)`;
    }
  }
  setInterval(()=>{ updateRotation(); updateCompass(); }, 500);

  // ---------- Compass ----------
  const compassNeedle = document.getElementById('compassNeedle');
  const compassLabel = document.getElementById('compassLabel');
  function updateCompass(){
    const bearing = lastHeading || 0;
    // Needle shows where North is relative to your view.
    // If course-up is ON and the map is rotated by -heading, then North is at +heading in the overlay.
    const relativeNorth = courseUp ? bearing : 0;
    compassNeedle.style.transform = `translateX(-50%) rotate(${relativeNorth}deg)`;
    compassLabel.textContent = courseUp && lastHeading!=null ? `${Math.round(bearing)}¬∞` : 'N';
  }

  // ---------- Simulate ----------
  let simTimer = null; let simIdx = 0;
  document.getElementById('btnSimulate').onclick = ()=>{
    const feats = toGeoJSONMulti();
    if(!feats.length){ alert('Tegn minst √©n linje f√∏rst.'); return; }
    const coords = [];
    feats.forEach(f => {
      f.geometry.coordinates.forEach(c=>coords.push([c[1], c[0]]));
    });
    if(simTimer){ clearInterval(simTimer); simTimer=null; }
    gpsCoords.length = 0; gpsLayer.clearLayers(); myDot=null; myAccuracy=null; headingMarker=null; gpsPolyline=null; simIdx=0;
    const speedMs = 6;
    const densified = densify(coords, 3);
    simTimer = setInterval(()=>{
      if(simIdx >= densified.length){ clearInterval(simTimer); simTimer=null; return; }
      const [lat, lon] = densified[simIdx++];
      const hdg = (simIdx<densified.length) ? bearingDeg([lat,lon], densified[simIdx]) : lastHeading;
      addGpsPoint(lat, lon, hdg, 8);
    }, Math.max(150, 1000 * (3 / speedMs)));
  };

  function densify(latlngs, everyMeters){
    const out = [];
    for(let i=0;i<latlngs.length-1;i++){
      const a = latlngs[i], b = latlngs[i+1];
      const segLen = distanceMeters(a,b);
      const steps = Math.max(1, Math.floor(segLen / everyMeters));
      for(let s=0; s<steps; s++){
        const t = s/steps; out.push( lerpLatLng(a,b,t) );
      }
    }
    out.push(latlngs[latlngs.length-1]);
    return out;
  }
  function distanceMeters(a,b){
    const R=6371000; const toRad=(x)=>x*Math.PI/180;
    const dLat=toRad(b[0]-a[0]); const dLon=toRad(b[1]-a[1]);
    const la=toRad(a[0]); const lb=toRad(b[0]);
    const h=Math.sin(dLat/2)**2 + Math.cos(la)*Math.cos(lb)*Math.sin(dLon/2)**2;
    return 2*R*Math.asin(Math.sqrt(h));
  }
  function lerpLatLng(a,b,t){ return [ a[0] + (b[0]-a[0])*t, a[1] + (b[1]-a[1])*t ]; }
  function bearingDeg(a,b){
    const toRad=(x)=>x*Math.PI/180, toDeg=(x)=>x*180/Math.PI;
    const lat1=toRad(a[0]), lat2=toRad(b[0]), dLon=toRad(b[1]-a[1]);
    const y=Math.sin(dLon)*Math.cos(lat2);
    const x=Math.cos(lat1)*Math.sin(lat2)-Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
    return (toDeg(Math.atan2(y,x)) + 360) % 360;
  }

  // ---------- Import/eksport ----------
  document.getElementById('btnExport').onclick = () => {
    const feats = toGeoJSONMulti();
    if(!feats.length){ alert('Ingen ruter √• eksportere.'); return; }
    const fc = { type:'FeatureCollection', features: feats };
    const blob = new Blob([JSON.stringify(fc, null, 2)], {type:'application/geo+json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'broytetraseer.geojson'; a.click();
    URL.revokeObjectURL(url);
  };

  document.getElementById('btnImport').onclick = async () => {
    const input = document.createElement('input');
    input.type='file'; input.accept='.geojson,application/geo+json,application/json';
    input.onchange = async () => {
      const file = input.files[0]; if(!file) return;
      const txt = await file.text();
      try{
        const gj = JSON.parse(txt);
        drawnLayer.clearLayers(); coveredLayer.clearLayers(); gpsLayer.clearLayers();
        if(gj.type==='FeatureCollection'){
          gj.features.forEach(feat => {
            if(feat.geometry?.type==='LineString'){
              const latlngs = feat.geometry.coordinates.map(c=>[c[1], c[0]]);
              const layer = L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
              layer.feature = feat;
            }
          });
        } else if(gj.type==='Feature' && gj.geometry?.type==='LineString'){
          const latlngs = gj.geometry.coordinates.map(c=>[c[1], c[0]]);
          const layer = L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
          layer.feature = gj;
        } else if(gj.type==='LineString'){
          const latlngs = gj.coordinates.map(c=>[c[1], c[0]]);
          L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
        } else {
          throw new Error('Importer FeatureCollection/Feature/LineString');
        }
        if(drawnLayer.getLayers().length){
          map.fitBounds(drawnLayer.getBounds(), {padding:[20,20]});
        }
        recalcRouteStats();
        markDirty();
      }catch(e){ alert('Kunne ikke importere: '+e.message); }
    };
    input.click();
  };

  // ---------- JSONBin ----------
  async function jsonbinGet(binId, key){
    const res = await fetch(`${JSONBIN_API}/${binId}/latest`, {
      headers: key ? { 'X-Master-Key': key } : {}
    });
    if(!res.ok) throw new Error('JSONBin GET feilet');
    const j = await res.json();
    return j.record;
  }
  async function jsonbinPut(binId, key, record){
    const res = await fetch(`${JSONBIN_API}/${binId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
        ...(key ? { 'X-Master-Key': key } : {})
      },
      body: JSON.stringify(record)
    });
    if(!res.ok) throw new Error('JSONBin PUT feilet');
    return res.json();
  }

  async function safeLoadFromJSONBin(){
    try{
      if(ADDR_BIN){
        const dataAddr = await jsonbinGet(ADDR_BIN, ADDR_KEY);
        addressLayer.clearLayers();
        const list = (dataAddr?.snapshot?.addresses) || dataAddr?.addresses || [];
        list.forEach(a => {
          if(a.lat && a.lon){
            const m = L.marker([a.lat, a.lon]).addTo(addressLayer);
            m.bindPopup(`<b>${(a.name || a.id || '').replace(/</g,'&lt;')}</b>`);
          }
        });
        if(addressLayer.getLayers().length){ map.fitBounds(addressLayer.getBounds(), {padding:[30,30]}); }
      }
      if(ROUTE_BIN){
        const dataRoute = await jsonbinGet(ROUTE_BIN, ROUTE_KEY);
        remoteVersion = (dataRoute?.meta?.routesVersion) || 0;
        const stored = dataRoute?.[FIELD];
        if(stored){
          drawnLayer.clearLayers();
          if(stored.type==='FeatureCollection'){
            stored.features.forEach(feat => {
              if(feat.geometry?.type==='LineString'){
                const latlngs = feat.geometry.coordinates.map(c=>[c[1], c[0]]);
                const layer = L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
                layer.feature = feat;
              }
            });
          } else if(stored.type==='Feature' && stored.geometry?.type==='LineString'){
            const latlngs = stored.geometry.coordinates.map(c=>[c[1], c[0]]);
            const layer = L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
            layer.feature = stored;
          } else if(stored.type==='LineString'){
            const latlngs = stored.coordinates.map(c=>[c[1], c[0]]);
            L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
          }
          if(drawnLayer.getLayers().length){
            map.fitBounds(drawnLayer.getBounds(), {padding:[20,20]});
          }
          recalcRouteStats();
        }
      }
    }catch(e){ console.warn('Last fra JSONBin feilet:', e); }
  }

  async function saveToJSONBin(){
    const feats = toGeoJSONMulti();
    if(!feats || feats.length===0){ alert('Ingen ruter √• lagre.'); return; }
    feats.forEach(f => { f.properties = f.properties || {}; f.properties.id = f.properties.id || (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random())); });

    try{
      const latest = ROUTE_BIN ? await jsonbinGet(ROUTE_BIN, ROUTE_KEY) : {};
      const latestVer = (latest?.meta?.routesVersion) || 0;
      const latestFC = latest?.[FIELD];

      let mergedFeatures = feats;
      if (latestFC?.type === 'FeatureCollection' && latestVer !== remoteVersion){
        const serverById = new Map(
          latestFC.features
            .filter(f => f?.properties?.id)
            .map(f => [f.properties.id, f])
        );
        const localById = new Map(feats.map(f => [f.properties.id, f]));
        const merged = new Map(serverById);
        for (const [id, lf] of localById.entries()){ merged.set(id, lf); }
        mergedFeatures = Array.from(merged.values());
      }

      const record = { ...(latest || {}) };
      record[FIELD] = { type:'FeatureCollection', features: mergedFeatures };
      record.meta = {
        ...(record.meta || {}),
        routesVersion: latestVer + 1,
        lastEditedAt: new Date().toISOString(),
        lastEditedBy: 'KartTegner'
      };

      await jsonbinPut(ROUTE_BIN, ROUTE_KEY, record);
      remoteVersion = record.meta.routesVersion;
      alert('Lagret til JSONBin!');
      dirty = false;
      localStorage.removeItem(LS_DRAFT);
    }catch(e){
      alert('Kunne ikke lagre: ' + e.message);
    }
  }

  document.getElementById('btnLoadBin').onclick = () => {
    if(!(ADDR_BIN || ROUTE_BIN)) { alert('Legg til #addrBin=... eller #routeBin=... i URL.'); return; }
    safeLoadFromJSONBin();
  };
  document.getElementById('btnSaveBin').onclick = () => {
    if(!ROUTE_BIN) { alert('Legg til #routeBin=... i URL for √• lagre ruter.'); return; }
    saveToJSONBin();
  };

  // ---------- Autosave (local draft) ----------
  function markDirty(){
    dirty = true;
    try {
      const feats = toGeoJSONMulti();
      const fc = { type:'FeatureCollection', features: feats };
      localStorage.setItem(LS_DRAFT, JSON.stringify(fc));
    } catch {}
  }
  document.getElementById('btnRestoreDraft').onclick = () => {
    try{
      const txt = localStorage.getItem(LS_DRAFT);
      if(!txt){ alert('Ingen lokalt utkast funnet.'); return; }
      const fc = JSON.parse(txt);
      if(fc?.type!=='FeatureCollection'){ alert('Ugyldig lokalt utkast.'); return; }
      drawnLayer.clearLayers(); coveredLayer.clearLayers(); gpsLayer.clearLayers();
      fc.features.forEach(feat=>{
        if(feat.geometry?.type==='LineString'){
          const latlngs = feat.geometry.coordinates.map(c=>[c[1], c[0]]);
          const layer = L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
          layer.feature = feat;
        }
      });
      if(drawnLayer.getLayers().length){
        map.fitBounds(drawnLayer.getBounds(), {padding:[20,20]});
      }
      recalcRouteStats();
    }catch(e){
      alert('Kunne ikke gjenopprette lokalt utkast.');
    }
  };

  window.addEventListener('beforeunload', (e) => {
    if(dirty){
      e.preventDefault();
      e.returnValue = '';
    }
  });

  // ---------- Back ----------
  const backBtn = document.getElementById('btnTilbake');
  backBtn.addEventListener('click', () => {
    window.location.href = BACK_URL;
  });

  // ---------- Wake Lock ----------
  let wakeLock = null;
  async function acquireWake(){
    try{
      if ('wakeLock' in navigator){
        wakeLock = await navigator.wakeLock.request('screen');
        document.getElementById('btnWake').textContent = 'üì± Hold skjerm p√• (p√•)';
        wakeLock.addEventListener('release', ()=>{
          document.getElementById('btnWake').textContent = 'üì± Hold skjerm p√• (av)';
        });
      } else {
        alert('Wake Lock st√∏ttes ikke p√• denne enheten.');
      }
    }catch(e){ console.warn('WakeLock:', e); }
  }
  async function releaseWake(){
    try{ await wakeLock?.release(); wakeLock=null; }catch{}
    document.getElementById('btnWake').textContent = 'üì± Hold skjerm p√• (av)';
  }
  document.getElementById('btnWake').onclick = async () => {
    if (wakeLock) releaseWake(); else acquireWake();
  };
  document.addEventListener('visibilitychange', () => {
    if (wakeLock && document.visibilityState === 'visible') { acquireWake(); }
  });

  // ---------- Autoload ----------
  if (ADDR_BIN || ROUTE_BIN) { safeLoadFromJSONBin(); }
  // Set initial compass
  updateCompass();
})();
</script>
</body>
</html>
