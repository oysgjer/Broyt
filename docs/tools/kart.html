<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>KartTegner ‚Äì feltmodus</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <style>
    :root {
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-left: env(safe-area-inset-left, 0px);
      --safe-right: env(safe-area-inset-right, 0px);

      --bg-header: #0f172a;
      --bg-btn: #1e293b;
      --bd-btn: #334155;
      --fg: #ffffff;
      --legend-bg: #ffffff;
      --legend-bd: #e5e7eb;
      --status-bg: #0b1220;
      --status-bd: #1f2937;
      --pill-bg: #1f2937;
      --pill-fg: #cbd5e1;
      --pill-bd: #334155;
      --accent: #16a34a;
      --danger: #ef4444;
      --info: #3b82f6;
    }
    [data-theme="light"] {
      --status-bg: #f8fafc;
      --status-bd: #e5e7eb;
      --pill-bg: #eef2ff;
      --pill-fg: #3730a3;
      --pill-bd: #c7d2fe;
      --legend-bg: #ffffff;
      --legend-bd: #e5e7eb;
    }

    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--status-bg); color: var(--fg); }
    #app { display: grid; grid-template-rows: auto 1fr auto; height: 100dvh; overflow:hidden; }

    header {
      padding: calc(8px + var(--safe-top)) 12px 8px 12px;
      background: var(--bg-header); color: var(--fg); display: flex; align-items: center;
      justify-content: space-between; position: sticky; top: 0; z-index: 1000;
    }
    .brand { display:flex; align-items:center; gap:.6rem; }
    .brand h1 { font-size: 1rem; margin: 0; font-weight: 600; }
    .quick { display:flex; align-items:center; gap:.5rem; }

    .hamburger {
      width: 40px; height: 40px; border-radius:10px; border:1px solid var(--bd-btn);
      background:var(--bg-btn); display:grid; place-items:center; cursor:pointer;
      -webkit-tap-highlight-color: transparent;
    }
    .hamburger div { width:18px; height:2px; background:var(--fg); position:relative; }
    .hamburger div::before, .hamburger div::after {
      content:""; position:absolute; left:0; width:18px; height:2px; background:var(--fg);
    }
    .hamburger div::before{ top:-6px; } .hamburger div::after{ top:6px; }

    .backdrop { position: fixed; inset: 0; background: rgba(0,0,0,.35); opacity: 0; pointer-events: none; transition: opacity .2s ease; z-index: 1190; }
    .backdrop.show { opacity: 1; pointer-events: auto; }

    .drawer {
      position: fixed; top:0; right:0; height:100%; width:min(92vw,460px);
      background:var(--bg-header); color:var(--fg); transform: translateX(100%);
      transition: transform .25s ease; z-index: 1200; display:flex; flex-direction:column;
      padding: calc(10px + var(--safe-top)) 12px calc(14px + var(--safe-bottom)) 12px; border-left:1px solid var(--bd-btn);
      overflow-y: auto; -webkit-overflow-scrolling: touch; touch-action: pan-y;
    }
    .drawer.open { transform: translateX(0); }
    .drawer header { display:flex; align-items:center; justify-content: space-between; gap:.6rem;
      position: sticky; top: calc(8px + var(--safe-top)); background: transparent; padding:0; z-index: 1; }
    .drawer h2{ margin:0; font-size:1rem }
    .close { background: var(--bg-btn); border:1px solid var(--bd-btn); color:var(--fg); padding:.4rem .6rem; border-radius:.6rem; }
    .group{ margin: .8rem 0 1.2rem 0; }
    .group h3{ font-size:.9rem; color:#9aa4bd; margin:.2rem 0 .6rem 0 }

    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap:.5rem; }
    .btn {
      background: var(--bg-btn); color: var(--fg); border: 1px solid var(--bd-btn);
      padding: .7rem .9rem; border-radius: .7rem; cursor: pointer;
      touch-action: manipulation; -webkit-tap-highlight-color: transparent;
      font-size: 1rem; width:100%; text-align:center;
    }
    .btn.active { outline: 2px solid var(--accent); }
    .note { color:#9aa4bd; font-size:.85rem; }

    #mapWrap { position:relative; overflow:hidden; background:#000; }
    #map { height: 100%; width: 100%; transform-origin:center center; }

    #statusbar {
      padding: 8px 12px calc(8px + var(--safe-bottom));
      background: var(--status-bg); border-top: 1px solid var(--status-bd);
      display: grid; grid-template-columns: 1fr; gap: .5rem; align-items: center;
      color: var(--fg);
    }
    @media (min-width: 720px) {
      #statusbar { grid-template-columns: 1fr auto; }
    }
    .progress { height: 12px; background: #475569; border-radius: 999px; overflow: hidden; }
    .progress > div { height: 100%; width: 0%; background: var(--accent); transition: width .3s ease; }
    .pill { font-size: .9rem; background: var(--pill-bg); color: var(--pill-fg); border: 1px solid var(--pill-bd); padding: .25rem .5rem; border-radius: 999px; }

    .legend {
      position: fixed; right: calc(12px + var(--safe-right)); top: calc(64px + var(--safe-top));
      background: var(--legend-bg); border: 1px solid var(--legend-bd); padding: .6rem; border-radius: .6rem;
      box-shadow: 0 4px 18px rgba(0,0,0,.18); z-index: 900; color:#111;
    }
    [data-theme="dark"] .legend{ color:#e5e7eb; }
    .legend h3{ margin:0 0 .5rem 0; font-size:.95rem }
    .legend .row{ font-size:.85rem; margin:.15rem 0; display:flex; align-items:center; gap:.35rem }
    .swatch{ width: 10px; height: 10px; border-radius: 2px; display:inline-block }
    .swatch.route{ background:var(--danger) }
    .swatch.covered{ background:var(--accent) }
    .swatch.gps{ background:var(--info) }

    .heading-arrow {
      width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent;
      border-bottom: 10px solid #1e40af;
      position: relative; top: -6px;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,.6));
    }

    .compass {
      position: fixed;
      left: calc(12px + var(--safe-left));
      top: calc(64px + var(--safe-top));
      z-index: 950;
      width: 44px; height: 44px;
      border-radius: 10px;
      background: var(--legend-bg);
      border:1px solid var(--legend-bd);
      display:grid; place-items:center;
      box-shadow: 0 2px 12px rgba(0,0,0,.12);
    }
    .compass .rose {
      width: 20px; height: 20px;
      border: 2px solid var(--danger); border-radius: 999px;
      position: relative;
    }
    .compass .needle {
      position: absolute; left: 50%; top: 0;
      transform: translateX(-50%);
      width: 0; height: 0;
      border-left: 6px solid transparent; border-right: 6px solid transparent;
      border-bottom: 12px solid var(--danger);
    }
    .compass .label {
      position: absolute; bottom: -18px; left: 50%; transform: translateX(-50%);
      font-size: 10px; color: #666;
    }
    [data-theme="dark"] .compass .label { color:#cbd5e1; }

    /* Toasts */
    #toasts { position: fixed; left: 50%; bottom: calc(12px + var(--safe-bottom)); transform: translateX(-50%);
      z-index: 1400; display: grid; gap: .4rem; width: min(92vw, 520px); }
    .toast { background: rgba(17,24,39,.96); color:#fff; padding:.7rem .9rem; border-radius:.7rem; box-shadow: 0 6px 30px rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.08); font-size:.95rem; }
    [data-theme="light"] .toast { background: rgba(31,41,55,.96); }
  </style>
</head>
<body>
<div id="app" data-theme="dark">
  <header>
    <div class="brand">
      <div class="hamburger" id="btnMenu"><div></div></div>
      <h1>KartTegner</h1>
    </div>
    <div class="quick">
      <button id="btnFollow" class="btn">üìç Sentrer (av)</button>
    </div>
  </header>

  <div id="mapWrap">
    <div id="map"></div>
  </div>

  <div id="statusbar">
    <div class="progress" aria-label="Dekningsgrad"><div id="bar"></div></div>
    <div style="display:flex; gap:.5rem; align-items:center; flex-wrap: wrap;">
      <span id="coverage" class="pill">Dekning: 0%</span>
      <span id="distance" class="pill">Rutelengde: 0 m</span>
      <span id="fix" class="pill">GPS: ‚Äì</span>
    </div>
  </div>
</div>

<div class="backdrop" id="backdrop"></div>

<aside class="drawer" id="drawer">
  <header>
    <h2>Meny</h2>
    <button class="close" id="btnCloseDrawer">Lukk ‚úñ</button>
  </header>

  <div class="group">
    <h3>Hurtig</h3>
    <div class="grid2">
      <button class="btn" id="btnBack">‚¨ÖÔ∏è Tilbake</button>
      <button class="btn" id="btnStartGPS">‚ñ∂Ô∏è Start GPS</button>
      <button class="btn" id="btnStopGPS">‚èπÔ∏è Stopp GPS</button>
      <button class="btn" id="btnCourseUp">üß≠ Kurs-opp</button>
      <button class="btn" id="btnWake">üì± Skjerm p√•</button>
      <button class="btn" id="btnTheme">üåô Natt: Auto</button>
    </div>
  </div>

  <div class="group">
    <h3>Ruter</h3>
    <div class="grid2">
      <button class="btn" id="btnDraw">‚úèÔ∏è Tegn</button>
      <button class="btn" id="btnFinish">‚úÖ Ferdig</button>
    </div>
    <div class="note" style="margin-top:.4rem">Alt lagres automatisk (lokalt + JSONBin n√•r mulig).</div>
  </div>

  <div class="group">
    <h3>Om</h3>
    <div class="note" id="metaInfo">v3.2 ‚Ä¢ autosave + toasts</div>
  </div>
</aside>

<div class="legend">
  <h3>Tegnforklaring</h3>
  <div class="row"><span class="swatch route"></span> Rute(r)</div>
  <div class="row"><span class="swatch covered"></span> Dekket del</div>
  <div class="row"><span class="swatch gps"></span> GPS-spor</div>
</div>
<div class="compass" id="compass" title="Nord">
  <div class="rose">
    <div class="needle" id="compassNeedle"></div>
    <div class="label" id="compassLabel">N</div>
  </div>
</div>

<div id="toasts" aria-live="polite" aria-atomic="true"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
<script>
(function(){
  function toast(msg, ms=2000){
    const wrap = document.getElementById('toasts');
    const el = document.createElement('div');
    el.className='toast'; el.textContent = msg;
    wrap.appendChild(el);
    setTimeout(()=>{ el.style.opacity='0'; el.style.transform='translateY(6px)'; }, ms-300);
    setTimeout(()=>{ el.remove(); }, ms);
    if (navigator.vibrate) navigator.vibrate(10);
  }

  const params = new URLSearchParams(location.hash.replace(/^#/, ''));
  const ADDR_BIN = params.get('addrBin') || params.get('bin') || '';
  const ADDR_KEY = params.get('addrKey') || params.get('key') || '';
  const ROUTE_BIN = params.get('routeBin') || ADDR_BIN;
  const ROUTE_KEY = params.get('routeKey') || ADDR_KEY;
  const FIELD = params.get('field') || 'geojsonRoutes';
  const BACK_URL = params.get('backUrl') || 'https://broyt.pages.dev/#work';
  const JSONBIN_API = 'https://api.jsonbin.io/v3/b';
  const LS_DRAFT = 'KARTTEGNER_DRAFT';
  const LS_THEME = 'KART_THEME_MODE';
  let remoteVersion = 0;

  const lightTiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap contributors' });
  const darkTiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 20, attribution: '&copy; OpenStreetMap, ¬©Carto' });

  const appEl = document.getElementById('app');
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)');
  let themeMode = localStorage.getItem(LS_THEME) || 'auto';

  function effectiveDark(){ if (themeMode==='dark') return true; if (themeMode==='light') return false; return !!(prefersDark && prefersDark.matches); }

  const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([60.2563, 11.1941], 14);
  function applyThemeToMap(){
    const dark = effectiveDark();
    appEl.setAttribute('data-theme', dark ? 'dark' : 'light');
    if (dark){ if (map.hasLayer(lightTiles)) map.removeLayer(lightTiles); if (!map.hasLayer(darkTiles)) darkTiles.addTo(map); }
    else { if (map.hasLayer(darkTiles)) map.removeLayer(darkTiles); if (!map.hasLayer(lightTiles)) lightTiles.addTo(map); }
    const btn = document.getElementById('btnTheme');
    btn.textContent = 'üåô Natt: ' + (themeMode==='auto' ? 'Auto' : (themeMode==='dark' ? 'P√•' : 'Av'));
    toast('Tema: ' + (themeMode==='auto'?'Auto':(themeMode==='dark'?'Natt':'Dag')), 1200);
  }
  applyThemeToMap();
  if (prefersDark && prefersDark.addEventListener){ prefersDark.addEventListener('change', applyThemeToMap); }
  document.getElementById('btnTheme').onclick = () => { themeMode = themeMode==='auto' ? 'dark' : (themeMode==='dark' ? 'light' : 'auto'); localStorage.setItem(LS_THEME, themeMode); applyThemeToMap(); };

  const drawnLayer   = new L.FeatureGroup().addTo(map);
  const coveredLayer = new L.FeatureGroup().addTo(map);
  const gpsLayer     = new L.FeatureGroup().addTo(map);
  const addressLayer = new L.FeatureGroup().addTo(map);

  const drawControl = new L.Control.Draw({
    draw: { polygon:false, rectangle:false, circle:false, circlemarker:false, marker:false,
      polyline: { shapeOptions: { color:'#ef4444', weight:4 } } },
    edit: { featureGroup: drawnLayer }
  });

  const drawer = document.getElementById('drawer');
  const backdrop = document.getElementById('backdrop');
  const btnMenu = document.getElementById('btnMenu');
  const btnCloseDrawer = document.getElementById('btnCloseDrawer');
  function openDrawer(){ drawer.classList.add('open'); backdrop.classList.add('show'); map.dragging.disable(); map.scrollWheelZoom.disable(); if (map.tap) map.tap.disable(); document.body.style.overflow = 'hidden'; }
  function closeDrawer(){ drawer.classList.remove('open'); backdrop.classList.remove('show'); map.dragging.enable(); map.scrollWheelZoom.enable(); if (map.tap) map.tap.enable(); document.body.style.overflow = ''; }
  btnMenu.addEventListener('click', openDrawer);
  btnCloseDrawer.addEventListener('click', closeDrawer);
  backdrop.addEventListener('click', closeDrawer);
  document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && drawer.classList.contains('open')) closeDrawer(); });
  // swipe to close
  let startX=null, startY=null, swiping=false;
  drawer.addEventListener('touchstart', (e)=>{ if (e.touches.length!==1) return; startX=e.touches[0].clientX; startY=e.touches[0].clientY; swiping=true; }, {passive:true});
  drawer.addEventListener('touchmove', (e)=>{ if(!swiping) return; const dx=e.touches[0].clientX-startX; const dy=e.touches[0].clientY-startY; if (Math.abs(dy)>Math.abs(dx)) return; if (dx>50){ closeDrawer(); swiping=false; }}, {passive:true});
  drawer.addEventListener('touchend', ()=>{ swiping=false; });

  // Back button
  const backBtn = document.getElementById('btnBack');
  backBtn.addEventListener('click', () => { closeDrawer(); try { window.location.assign(BACK_URL); } catch { history.back(); } });

  // Follow me
  let followEnabled = false;
  document.getElementById('btnFollow').addEventListener('click', () => {
    followEnabled = !followEnabled;
    const btn = document.getElementById('btnFollow');
    btn.textContent = followEnabled ? 'üìç Sentrer (p√•)' : 'üìç Sentrer (av)';
    btn.classList.toggle('active', followEnabled);
    if(followEnabled && lastLatLng){ const targetZoom = Math.max(map.getZoom()||14, 16); map.setView(lastLatLng, targetZoom, { animate:true }); }
    toast(followEnabled ? 'F√∏lger posisjon' : 'F√∏lger av');
  });
  map.on('dragstart', () => {
    if (followEnabled) {
      followEnabled = false;
      const btn = document.getElementById('btnFollow');
      btn.textContent = 'üìç Sentrer (av)';
      btn.classList.remove('active');
      toast('F√∏lger av');
    }
  });

  // Drawing
  let dirty = false;
  document.getElementById('btnDraw').onclick = () => { new L.Draw.Polyline(map, drawControl.options.draw.polyline).enable(); toast('Tegning: p√•'); };
  document.getElementById('btnFinish').onclick = () => { map.fire('draw:drawstop'); toast('Tegning: ferdig'); };

  map.on(L.Draw.Event.CREATED, (e) => {
    const layer = e.layer;
    const name = prompt('Navn p√• strekning?', 'Ny br√∏ytestrek') || 'Uten navn';
    layer.feature = layer.feature || { type:'Feature', properties:{} };
    layer.feature.properties.name = name;
    layer.feature.properties.id = layer.feature.properties.id || (crypto?.randomUUID ? crypto.randomUUID() : String(Date.now()+Math.random()));
    layer.addTo(drawnLayer);
    map.fitBounds(layer.getBounds(), { padding:[20,20] });
    recalcRouteStats();
    markDirtyAndScheduleSave();
  });

  map.on(L.Draw.Event.EDITED, () => { recalcRouteStats(); markDirtyAndScheduleSave(); });

  // Coverage sampling
  let samples = [];
  const SAMPLE_EVERY_M = 5;
  const TOLERANCE_M = 12;
  let covered = new Set();

  function recalcRouteStats(){
    covered.clear();
    coveredLayer.clearLayers();
    const gjs = toGeoJSONMulti();
    if(!gjs || gjs.length===0) { updateUI(0, 0); samples=[]; return; }
    let meters = 0;
    samples = [];
    gjs.forEach(gj => {
      const lenKm = turf.length(gj, {units:'kilometers'});
      meters += Math.round(lenKm * 1000);
      const steps = Math.max(1, Math.ceil((lenKm*1000) / SAMPLE_EVERY_M));
      for(let i=0;i<=steps;i++){
        const distKm = (i * SAMPLE_EVERY_M) / 1000;
        const pt = turf.along(gj, distKm, {units:'kilometers'});
        samples.push(pt);
      }
    });
    updateUI(0, meters);
  }

  function toGeoJSONMulti(){
    const layers = drawnLayer.getLayers();
    if(layers.length===0) return [];
    return layers.map(l => l.toGeoJSON()).filter(f => f.geometry?.type==='LineString');
  }

  function updateUI(percent, meters){
    const bar = document.getElementById('bar');
    bar.style.width = `${percent}%`;
    document.getElementById('coverage').textContent = `Dekning: ${percent.toFixed(0)}%`;
    document.getElementById('distance').textContent = `Rutelengde: ${meters} m`;
  }
  function totalMeters(){
    const gjs = toGeoJSONMulti();
    let m=0; gjs.forEach(gj => m += Math.round(turf.length(gj,{units:'kilometers'})*1000));
    return m;
  }

  function markCovered(indices){
    if(!indices || indices.length===0) return;
    indices.forEach(i => covered.add(i));
    const coveredPts = Array.from(covered).sort((a,b)=>a-b).map(i=>samples[i]);
    if(coveredPts.length>0){
      coveredLayer.clearLayers();
      const coords = coveredPts.map(pt => pt.geometry.coordinates).map(c=>[c[1], c[0]]);
      L.polyline(coords, {color:'#16a34a', weight:6, opacity:0.6}).addTo(coveredLayer);
    }
    const pct = samples.length? Math.min(100, (covered.size / samples.length) * 100) : 0;
    const meters = totalMeters();
    updateUI(pct, meters);
  }

  // GPS + heading + course-up
  let watchId = null;
  let gpsPolyline = null;
  const gpsCoords = [];
  let myDot = null;
  let headingMarker = null;
  let myAccuracy = null;
  let lastLatLng = null;
  let lastHeading = null;

  function ensureHeadingMarker(latlng){
    if (!headingMarker){
      const div = document.createElement('div');
      div.className = 'heading-arrow';
      const icon = L.divIcon({ className:'', html:div, iconSize:[12,10], iconAnchor:[6,6] });
      headingMarker = L.marker(latlng, { icon }).addTo(gpsLayer);
    }
  }

  function addGpsPoint(lat, lon, heading, accuracy){
    const latlng = [lat, lon];
    lastLatLng = latlng;
    lastHeading = (typeof heading === 'number' && !Number.isNaN(heading)) ? heading : lastHeading;

    gpsCoords.push(latlng);
    if(!gpsPolyline){ gpsPolyline = L.polyline(gpsCoords, {color:'#3b82f6', weight:3}).addTo(gpsLayer); }
    else { gpsPolyline.setLatLngs(gpsCoords); }

    if(!myDot){
      myDot = L.circleMarker(latlng, { radius:5, color:'#1d4ed8', fillColor:'#1d4ed8', fillOpacity:1, stroke:false }).addTo(gpsLayer);
    } else { myDot.setLatLng(latlng); }

    ensureHeadingMarker(latlng);
    headingMarker.setLatLng(latlng);
    if (lastHeading != null){
      const el = headingMarker.getElement();
      if (el) el.style.transform = `rotate(${lastHeading}deg)`;
    }

    if (typeof accuracy === 'number'){
      if(!myAccuracy){ myAccuracy = L.circle(latlng, { radius: Math.max(5, Math.min(100, accuracy)), color:'#3b82f6', weight:1, fillOpacity:0.1 }).addTo(gpsLayer); }
      else { myAccuracy.setLatLng(latlng); myAccuracy.setRadius(Math.max(5, Math.min(100, accuracy))); }
      document.getElementById('fix').textContent = `GPS: ${Math.round(accuracy)}m`;
    }

    if(samples.length>0){
      const pt = turf.point([lon, lat]);
      let nearestIdx = 0; let best = Infinity;
      for(let i=0;i<samples.length;i++){
        const d = turf.distance(pt, samples[i], {units:'kilometers'});
        if(d<best){ best=d; nearestIdx=i; }
      }
      const found = [];
      const maxJump = 25;
      for(let j=Math.max(0, nearestIdx-maxJump); j<=Math.min(samples.length-1, nearestIdx+maxJump); j++){
        const m = turf.distance(pt, samples[j], {units:'kilometers'}) * 1000;
        if(m <= TOLERANCE_M) found.push(j);
      }
      markCovered(found);
    }

    if(followEnabled){
      const targetZoom = Math.max(map.getZoom() || 14, 16);
      map.setView(latlng, targetZoom, { animate: true });
    }
  }

  function startGPS(){ if(watchId!==null) return; if(!navigator.geolocation){ toast('Ingen GPS p√• enheten'); return; }
    watchId = navigator.geolocation.watchPosition(pos => {
      const { latitude, longitude, accuracy, heading } = pos.coords;
      addGpsPoint(latitude, longitude, heading, accuracy);
    }, err => { document.getElementById('fix').textContent = 'GPS: feil'; console.error(err); toast('GPS-feil'); }, { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 });
    toast('GPS startet');
  }
  function stopGPS(){ if(watchId!==null){ navigator.geolocation.clearWatch(watchId); watchId = null; } document.getElementById('fix').textContent = 'GPS: stoppet'; toast('GPS stoppet'); }

  document.getElementById('btnStartGPS').onclick = startGPS;
  document.getElementById('btnStopGPS').onclick = stopGPS;

  // Course-up rotation
  let courseUp = false;
  const mapEl = document.getElementById('map');
  document.getElementById('btnCourseUp').onclick = () => {
    courseUp = !courseUp;
    document.getElementById('btnCourseUp').textContent = courseUp ? 'üß≠ Kurs-opp (p√•)' : 'üß≠ Kurs-opp';
    if(!courseUp){ mapEl.style.transform = 'rotate(0deg)'; }
    else if (lastHeading != null){ mapEl.style.transform = `rotate(${-lastHeading}deg)`; }
    updateCompass();
    toast(courseUp ? 'Kurs-opp p√•' : 'Kurs-opp av');
  };
  function updateRotation(){ if(courseUp && lastHeading != null){ mapEl.style.transform = `rotate(${-lastHeading}deg)`; } }
  setInterval(()=>{ updateRotation(); updateCompass(); }, 500);

  const compassNeedle = document.getElementById('compassNeedle');
  const compassLabel = document.getElementById('compassLabel');
  function updateCompass(){
    const bearing = lastHeading || 0;
    const relativeNorth = courseUp ? bearing : 0;
    compassNeedle.style.transform = `translateX(-50%) rotate(${relativeNorth}deg)`;
    compassLabel.textContent = courseUp && lastHeading!=null ? `${Math.round(bearing)}¬∞` : 'N';
  }

  // Autosave (local + JSONBin)
  function currentFC(){ const feats = toGeoJSONMulti(); return { type:'FeatureCollection', features: feats }; }
  function saveLocalDraft(){ try { localStorage.setItem(LS_DRAFT, JSON.stringify(currentFC())); } catch {} }
  let saveTimer = null;
  function markDirtyAndScheduleSave(){ dirty = true; saveLocalDraft(); if (saveTimer) clearTimeout(saveTimer); saveTimer = setTimeout(syncRemote, 1200); }

  async function jsonbinGet(binId, key){
    const res = await fetch(`https://api.jsonbin.io/v3/b/${binId}/latest`, { headers: key ? { 'X-Master-Key': key } : {} });
    if(!res.ok) throw new Error('JSONBin GET feilet');
    const j = await res.json(); return j.record;
  }
  async function jsonbinPut(binId, key, record){
    const res = await fetch(`https://api.jsonbin.io/v3/b/${binId}`, { method: 'PUT', headers: { 'Content-Type':'application/json', ...(key ? { 'X-Master-Key': key } : {}) }, body: JSON.stringify(record) });
    if(!res.ok) throw new Error('JSONBin PUT feilet');
    return res.json();
  }

  async function syncRemote(){
    if (!ROUTE_BIN) return;
    try {
      const latest = await jsonbinGet(ROUTE_BIN, ROUTE_KEY);
      const latestVer = (latest?.meta?.routesVersion) || 0;
      const latestFC = latest?.[FIELD];
      const mine = currentFC();

      const serverById = new Map((latestFC?.features||[]).filter(f=>f?.properties?.id).map(f=>[f.properties.id, f]));
      const localById  = new Map((mine.features||[]).filter(f=>f?.properties?.id).map(f=>[f.properties.id, f]));
      const merged = new Map(serverById);
      for (const [id, lf] of localById.entries()){ merged.set(id, lf); }
      const mergedFeatures = Array.from(merged.values());

      const record = { ...(latest || {}) };
      record[FIELD] = { type:'FeatureCollection', features: mergedFeatures };
      record.meta = { ...(record.meta||{}), routesVersion: latestVer + 1, lastEditedAt: new Date().toISOString(), lastEditedBy: 'KartTegner' };

      await jsonbinPut(ROUTE_BIN, ROUTE_KEY, record);
      remoteVersion = record.meta.routesVersion;
      dirty = false;
      toast('Lagret');
    } catch (e) {
      console.warn('Autosave remote feilet', e);
      toast('Lagret lokalt (offline)', 1800);
    }
  }

  async function safeLoad(){
    let loaded = false;
    try {
      if (ADDR_BIN){
        const dataAddr = await jsonbinGet(ADDR_BIN, ADDR_KEY);
        const list = (dataAddr?.snapshot?.addresses) || dataAddr?.addresses || [];
        list.forEach(a => { if(a.lat && a.lon){ const m = L.marker([a.lat, a.lon]).addTo(addressLayer); m.bindPopup(`<b>${(a.name || a.id || '').replace(/</g,'&lt;')}</b>`); } });
        if(addressLayer.getLayers().length){ map.fitBounds(addressLayer.getBounds(), {padding:[30,30]}); }
      }
    } catch (e) {}

    try {
      if (ROUTE_BIN){
        const dataRoute = await jsonbinGet(ROUTE_BIN, ROUTE_KEY);
        remoteVersion = (dataRoute?.meta?.routesVersion) || 0;
        const stored = dataRoute?.[FIELD];
        if(stored?.type==='FeatureCollection'){
          (stored.features||[]).forEach(feat => {
            if(feat.geometry?.type==='LineString'){
              const latlngs = feat.geometry.coordinates.map(c=>[c[1], c[0]]);
              const layer = L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
              layer.feature = feat;
            }
          });
          if(drawnLayer.getLayers().length){ map.fitBounds(drawnLayer.getBounds(), {padding:[20,20]}); }
          recalcRouteStats();
          loaded = true;
        }
      }
    } catch (e) { console.warn('Fikk ikke ruter fra JSONBin', e); }

    if (!loaded){
      try {
        const txt = localStorage.getItem(LS_DRAFT);
        if (txt){
          const fc = JSON.parse(txt);
          (fc.features||[]).forEach(feat => {
            if(feat.geometry?.type==='LineString'){
              const latlngs = feat.geometry.coordinates.map(c=>[c[1], c[0]]);
              const layer = L.polyline(latlngs, {color:'#ef4444', weight:4}).addTo(drawnLayer);
              layer.feature = feat;
            }
          });
          if(drawnLayer.getLayers().length){ map.fitBounds(drawnLayer.getBounds(), {padding:[20,20]}); }
          recalcRouteStats();
          toast('Lastet lokalt utkast', 1400);
        }
      } catch (e){}
    }
  }

  // Wake Lock
  let wakeLock = null;
  async function acquireWake(){ try{ if ('wakeLock' in navigator){ wakeLock = await navigator.wakeLock.request('screen'); document.getElementById('btnWake').textContent = 'üì± Skjerm p√• (p√•)'; wakeLock.addEventListener('release', ()=>{ document.getElementById('btnWake').textContent = 'üì± Skjerm p√•'; }); } else { toast('Wake Lock st√∏ttes ikke'); } }catch(e){ console.warn('WakeLock:', e); } }
  async function releaseWake(){ try{ await wakeLock?.release(); wakeLock=null; }catch{} document.getElementById('btnWake').textContent = 'üì± Skjerm p√•'; }
  document.getElementById('btnWake').onclick = async () => { if (wakeLock) releaseWake(); else acquireWake(); };
  document.addEventListener('visibilitychange', () => { if (wakeLock && document.visibilityState === 'visible') { acquireWake(); } });

  // Init
  safeLoad().then(()=> toast('Klar'));
  if (navigator.onLine === false) toast('Offline-modus');
  window.addEventListener('online', ()=> toast('Online'));
  window.addEventListener('offline', ()=> toast('Offline'));

  // Compass init
  updateCompass();
})();
</script>
</body>
</html>
